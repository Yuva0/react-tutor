"use strict";(self.webpackChunkcstutor=self.webpackChunkcstutor||[]).push([[165],{9165:(e,t,i)=>{i.r(t),i.d(t,{default:()=>o});var n=i(5043),r=i(4306),s=i(1290),a=i(7987),c=i(579);const l=[{id:"introduction",title:"Introduction"},{id:"tradition-dom",title:"Traditional DOM"},{id:"what-is-the-virtual-dom",title:"What is the Virtual DOM?"},{id:"benefits-of-the-virtual-dom",title:"Benefits of the Virtual DOM"},{id:"conclusion",title:"Conclusion"}],o=()=>{const[e,t]=n.useState("introduction"),[i,o]=n.useState(!1),{width:h}=(0,a.lW)(),d=h<1200;n.useEffect((()=>{o(!0)}),[]),n.useEffect((()=>{const e=new IntersectionObserver((e=>{for(const i of e)if(i.isIntersecting){t(i.target.id);break}}),{threshold:1,rootMargin:"64px"});return l.map((e=>document.getElementById(e.id))).forEach((t=>{if(t)return e.observe(t)})),()=>{e.disconnect()}}));const u=(0,r.DP)().theme.colorPalette.primary.accentScale[10],p=e=>{let{children:t}=e;return(0,c.jsx)("span",{style:{color:u},children:t})},f=(0,c.jsxs)(r.EY,{children:["The Virtual DOM (VDOM) is a core concept in React that plays a"," ",(0,c.jsx)(p,{children:"significant role in how React efficiently updates the user interface (UI)."})," ","Understanding the Virtual DOM requires a basic grasp of how traditional DOM (Document Object Model) manipulation works in web development."]});return(0,c.jsxs)(s.Hk,{children:[(0,c.jsxs)(s._f,{className:i?"fade-in":"",style:{width:d?"100%":"calc(100% - 12rem"},children:[(0,c.jsx)(s.PZ,{id:"introduction",children:(0,c.jsxs)(s.db,{children:[(0,c.jsxs)(r.BI,{size:"small",delimiter:"/",children:[(0,c.jsx)(r.yd,{title:"Guides"}),(0,c.jsx)(r.yd,{link:"/guides/virtual-dom",title:"Virtual DOM"})]}),(0,c.jsx)(r.EY,{size:"large",style:{marginTop:"1rem"},children:"Introduction"}),f,(0,c.jsx)(r.EY,{children:"When a component's state changes, the Virtual DOM is updated to reflect the new state. The Virtual DOM is then compared to the actual DOM, and only the differences are applied to the actual DOM. This process is known as reconciliation."}),(0,c.jsx)(r.EY,{children:"The Virtual DOM is used by libraries like React to efficiently update the DOM without the need for manual DOM manipulation."})]})}),(0,c.jsxs)(s.PZ,{id:"traditional-dom",children:[(0,c.jsx)(r.EY,{size:"large",children:"Traditional DOM"}),(0,c.jsxs)(s.db,{children:[(0,c.jsxs)(r.EY,{children:["The DOM is a"," ",(0,c.jsx)(p,{children:"programming interface for web documents,"})," ","representing the page's structure as a tree of objects. Each element on the page is a node in this tree. Manipulating the DOM, such as changing an element's content, style, or structure, involves interacting with this tree."]}),(0,c.jsxs)(r.EY,{children:["However, directly manipulating the DOM is slow and inefficient, particularly when dealing with complex UIs or frequent updates. Each change to the DOM triggers a series of steps in the browser,"," ",(0,c.jsxs)(p,{children:["including recalculating styles, updating the layout, and repainting the page, which can lead to performance bottlenecks."," "]})]})]})]}),(0,c.jsxs)(s.PZ,{id:"what-is-the-virtual-dom",children:[(0,c.jsx)(r.EY,{size:"large",children:"What is the Virtual DOM?"}),(0,c.jsxs)(s.db,{children:[(0,c.jsxs)(r.EY,{children:["The Virtual DOM is an in-memory representation of the real DOM elements generated by React components. It is a lightweight copy of the real DOM, keeping track of the elements and their attributes as a JavaScript object."," ",(0,c.jsx)(p,{children:"The key difference is that the Virtual DOM does not directly interact with the browser."})]}),(0,c.jsxs)(r.B8,{title:"Initial Rendering",variant:"unordered",children:[(0,c.jsx)(r.ck,{children:(0,c.jsx)(r.EY,{children:"When a React application renders for the first time, React creates a Virtual DOM tree that represents the current state of the UI."})}),(0,c.jsx)(r.ck,{children:(0,c.jsx)(r.EY,{children:"React components are converted into Virtual DOM nodes, and this tree is compared with the real DOM to update the browser's UI."})})]}),(0,c.jsxs)(r.B8,{title:"Updating the UI:",children:[(0,c.jsx)(r.ck,{children:(0,c.jsxs)(r.EY,{children:["When the state or props of a component change,"," ",(0,c.jsx)(p,{children:"React creates a new Virtual DOM tree representing the updated UI."})]})}),(0,c.jsx)(r.ck,{children:(0,c.jsxs)(r.EY,{children:["React then compares this new Virtual DOM tree with the previous one."," ",(0,c.jsx)(p,{children:'This process is known as "reconciliation."'})]})})]}),(0,c.jsxs)(r.B8,{title:"Reconciliation",children:[(0,c.jsx)(r.ck,{children:(0,c.jsxs)(r.EY,{children:["React uses a highly efficient algorithm to compare the new"," ",(0,c.jsx)(p,{children:"Virtual DOM with the previous one."})," ",'This algorithm is known as the "diffing algorithm."']})}),(0,c.jsx)(r.ck,{children:(0,c.jsx)(r.EY,{children:"Instead of re-rendering the entire UI, React identifies the specific parts of the Virtual DOM that have changed."})}),(0,c.jsx)(r.ck,{children:(0,c.jsxs)(r.EY,{children:["Once React has identified the changes, it updates only those specific parts of the real DOM, making the update process",(0,c.jsx)(p,{children:"faster and more efficient."})]})})]}),(0,c.jsxs)(r.B8,{title:"Batching and Optimization:",children:[(0,c.jsx)(r.ck,{children:(0,c.jsxs)(r.EY,{children:["React batches updates to reduce the number of changes made to the DOM. Multiple state updates occurring in a short period are batched together, leading to"," ",(0,c.jsx)(p,{children:"fewer DOM manipulations."})]})}),(0,c.jsx)(r.ck,{children:(0,c.jsx)(r.EY,{children:"React's reconciliation process also uses a heuristic called \u201ckeying\u201d to optimize the update process further. When rendering lists of elements, adding a unique key prop helps React identify which items have changed, been added, or removed, allowing for more efficient updates."})})]})]})]}),(0,c.jsxs)(s.PZ,{id:"benefits-of-the-virtual-dom",children:[(0,c.jsx)(r.EY,{size:"large",children:"Benefits of the Virtual DOM"}),(0,c.jsxs)(r.B8,{title:"Here are the benefits",children:[(0,c.jsx)(r.ck,{children:(0,c.jsxs)(r.EY,{children:["Performance: By minimizing direct interactions with the real DOM,"," ",(0,c.jsx)(p,{children:"React can perform updates much more quickly, leading to smoother user experiences,"})," ","especially in dynamic applications with frequent updates."]})}),(0,c.jsx)(r.ck,{children:(0,c.jsxs)(r.EY,{children:["Abstraction: The Virtual DOM abstracts the complexity of manual DOM manipulation, allowing developers to focus on building components and managing state"," ",(0,c.jsx)(p,{children:"without worrying about the underlying DOM operations."})]})}),(0,c.jsx)(r.ck,{children:(0,c.jsxs)(r.EY,{children:["Cross-Browser Compatibility: Since React handles the Virtual DOM internally, it also manages differences in how various browsers interact with the DOM,"," ",(0,c.jsx)(p,{children:"making your code more consistent across different environments."})]})})]})]}),(0,c.jsxs)(s.PZ,{id:"conclusion",children:[(0,c.jsx)(r.EY,{size:"large",children:"Conclusion"}),(0,c.jsx)(s.db,{children:(0,c.jsxs)(r.EY,{children:["The Virtual DOM is a powerful concept that allows React to update the UI efficiently without the need for direct, frequent interactions with the real DOM. By comparing Virtual DOM trees and updating only the parts that change,"," ",(0,c.jsx)(p,{children:"React ensures that applications remain responsive and performant"})," ",", even as they grow in complexity."]})})]})]}),!d&&(0,c.jsx)(r.Sr,{top:"6rem",right:"4rem",children:l.map((t=>(0,c.jsx)(r.WW,{size:"small",selected:e===t.id,onClick:()=>(e=>{const t=document.getElementById(e);t&&t.scrollIntoView({behavior:"smooth",block:"start",inline:"nearest"})})(t.id),children:t.title},t.id)))})]})}}}]);
//# sourceMappingURL=165.ef69c41d.chunk.js.map