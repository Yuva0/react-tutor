"use strict";(self.webpackChunkcstutor=self.webpackChunkcstutor||[]).push([[872],{1872:(e,n,t)=>{t.r(n),t.d(n,{default:()=>l});var i=t(5043),o=t(1290),s=t(4306),c=t(7987),r=t(579);const a=[{id:"introduction",title:"Introduction"},{id:"detailed-breakdown",title:"Detailed Breakdown"},{id:"practical-example",title:"Practical Example"},{id:"summary",title:"Summary"}],l=()=>{const[e,n]=i.useState("introduction"),[t,l]=i.useState(!1),{width:d}=(0,c.lW)(),h=d<1200;i.useEffect((()=>{l(!0)}),[]),i.useEffect((()=>{const e=new IntersectionObserver((e=>{for(const t of e)if(t.isIntersecting){n(t.target.id);break}}),{threshold:1,rootMargin:"64px"});return a.map((e=>document.getElementById(e.id))).forEach((n=>{if(n)return e.observe(n)})),()=>{e.disconnect()}}));const u=(0,s.DP)().theme.colorPalette.primary.accentScale[10],m=e=>{let{children:n}=e;return(0,r.jsx)("span",{style:{color:u},children:n})},p=(0,r.jsxs)(s.EY,{children:["useCallback is a hook provided by React that allows you to memoize a function. Memoization is a process where you cache the result of an expensive computation so that it doesn't have to be recalculated every time it's needed. useCallback is used to optimize the performance of React components by"," ",(0,r.jsx)(m,{children:"preventing unnecessary re-creation of functions on every render."})]}),y=(0,r.jsxs)(s.EY,{children:["When you define a function inside a React component, that function gets"," ",(0,r.jsx)(m,{children:"re-created on every render."})," This can be problematic if you pass that function as a prop to a child component, causing the child component to re-render unnecessarily."]}),x=(0,r.jsxs)(s.EY,{children:["While useCallback can help with performance by preventing unnecessary re-creations of functions, it's essential to use it judiciously. Overusing useCallback can lead to overly complex dependency arrays and make the code harder to read and maintain. Additionally, memoization itself has a cost,"," ",(0,r.jsx)(m,{children:"so it's only beneficial if the memoized function is expensive to re-create or if it causes unnecessary re-renders."})]}),k=(0,r.jsxs)(s.EY,{children:["In this example, the handleClick function is re-created on every render of MyComponent. If MyComponent is a parent component and handleClick is passed as a prop to a child component,"," ",(0,r.jsx)(m,{children:"the child component will re-render every time MyComponent re-renders, even if handleClick hasn't changed."})]});return t?(0,r.jsxs)(o.Hk,{children:[(0,r.jsxs)(o._f,{style:{width:h?"100%":"calc(100% - 12rem"},className:t?"fade-in":"",children:[(0,r.jsx)(o.PZ,{id:"introduction",children:(0,r.jsxs)(o.db,{children:[(0,r.jsxs)(s.BI,{size:"small",color:"primary",delimiter:"/",children:[(0,r.jsx)(s.yd,{title:"Hooks"}),(0,r.jsx)(s.yd,{link:"/hooks/use-callback",title:"useCallback"})]}),(0,r.jsx)(s.EY,{size:"large",style:{marginTop:"1rem"},children:"Introduction"}),(0,r.jsx)(s.EY,{children:p}),(0,r.jsx)(s.EY,{size:"large",children:"Basic Usage"}),(0,r.jsx)(s.EY,{children:"Here's the basic syntax of useCallback:"}),(0,r.jsx)(s.sY,{text:"const memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n",language:"javascript"}),(0,r.jsx)(s.EY,{style:{marginTop:"0.5rem"},children:"In this example, useCallback will return a memoized version of the doSomething function that only changes if a or b change. The dependencies are specified in the dependency array [a, b]."})]})}),(0,r.jsx)(o.PZ,{id:"detailed-breakdown",children:(0,r.jsx)(o.db,{children:(0,r.jsxs)(s.B8,{title:(0,r.jsx)(s.EY,{size:"large",children:"Detailed Breakdown"}),children:[(0,r.jsxs)(s.ck,{children:[(0,r.jsx)(s.EY,{children:"Function Definition"}),(0,r.jsx)(s.EY,{style:{marginTop:"0.25rem"},children:y}),(0,r.jsx)(s.EY,{style:{marginTop:"0.5rem"},children:"Example without `useCallback`:"}),(0,r.jsx)(s.sY,{text:"const MyComponent = () => {\n  const handleClick = () => {\n    console.log('Button clicked');\n  };\n\n  return <button onClick={handleClick}>Click Me</button>;\n};\n",language:"javascript",style:{marginTop:"0.5rem"}}),(0,r.jsx)(s.EY,{style:{marginTop:"1rem"},children:k})]}),(0,r.jsxs)(s.ck,{style:{marginTop:"1rem"},children:[(0,r.jsx)(s.EY,{children:"Memoization with `useCallback`"}),(0,r.jsx)(s.EY,{style:{marginTop:"0.5rem"},children:"To prevent this, you can use useCallback to memoize the function:"}),(0,r.jsx)(s.sY,{text:"const MyComponent = () => {\n  const handleClick = useCallback(() => {\n    console.log('Button clicked');\n  }, []);\n\n  return <button onClick={handleClick}>Click Me</button>;\n};\n",language:"javascript",style:{marginTop:"0.5rem"}}),(0,r.jsx)(s.EY,{style:{marginTop:"1rem"},children:"By using useCallback to memoize the handleClick function, the function is only created once and will not change on subsequent renders. This prevents unnecessary re-renders of child components that depend on handleClick."})]}),(0,r.jsxs)(s.ck,{style:{marginTop:"1rem"},children:[(0,r.jsx)(s.EY,{children:"Dependencies"}),(0,r.jsx)(s.EY,{style:{marginTop:"0.5rem"},children:"The dependency array is crucial for useCallback. It tells React when to re-create the memoized function. If you don't include the correct dependencies, you might end up with stale values."}),(0,r.jsx)(s.sY,{style:{marginTop:"0.5rem"},text:"const MyComponent = ({ a, b }) => {\n  const handleClick = useCallback(() => {\n    console.log(a, b);\n  }, [a, b]);\n\n  return <button onClick={handleClick}>Click Me</button>;\n};\n",language:"javascript"}),(0,r.jsx)(s.EY,{style:{marginTop:"1rem"},children:"In this example, the handleClick function depends on the values of a and b. By including [a, b] in the dependency array, React will re-create the memoized function whenever a or b changes."})]}),(0,r.jsxs)(s.ck,{style:{marginTop:"1rem"},children:[(0,r.jsx)(s.EY,{children:"Performance Considerations"}),(0,r.jsx)(s.EY,{style:{marginTop:"0.5rem"},children:x})]})]})})}),(0,r.jsx)(o.PZ,{id:"practical-example",children:(0,r.jsxs)(o.db,{children:[(0,r.jsx)(s.EY,{size:"large",children:"Practical Example"}),(0,r.jsx)(s.EY,{children:"Consider a scenario where you have a parent component and a child component. The child component receives a callback as a prop."}),(0,r.jsx)(s.EY,{children:"Without useCallback:"}),(0,r.jsx)(s.sY,{text:"const ParentComponent = () => {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    console.log('Button clicked');\n  };\n\n  return (\n    <div>\n      <ChildComponent onClick={handleClick} />\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n};\n\nconst ChildComponent = React.memo(({ onClick }) => {\n  console.log('Child rendered');\n  return <button onClick={onClick}>Click Me</button>;\n});\n",language:"javascript"}),(0,r.jsxs)(s.EY,{style:{marginTop:"0.5rem"},children:["In this example, every time ParentComponent re-renders, handleClick is re-created,"," ",(0,r.jsx)(m,{children:"causing ChildComponent to re-render even though it doesn't need to."})]}),(0,r.jsx)(s.EY,{style:{marginTop:"0.5rem"},children:"With useCallback:"}),(0,r.jsx)(s.sY,{text:"const ParentComponent = () => {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    console.log('Button clicked');\n  }, []);\n\n  return (\n    <div>\n      <ChildComponent onClick={handleClick} />\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n};\n\nconst ChildComponent = React.memo(({ onClick }) => {\n  console.log('Child rendered');\n  return <button onClick={onClick}>Click Me</button>;\n});\n",language:"javascript"}),(0,r.jsxs)(s.EY,{style:{marginTop:"0.5rem"},children:["By using useCallback to memoize handleClick, the function is only created once and will not change on subsequent renders."," ",(0,r.jsx)(m,{children:"This prevents unnecessary re-renders of ChildComponent."})]})]})}),(0,r.jsx)(o.PZ,{id:"summary",children:(0,r.jsxs)(o.db,{children:[(0,r.jsx)(s.EY,{size:"large",children:"Summary"}),(0,r.jsxs)(s.B8,{variant:"unordered",title:(0,r.jsx)(s.EY,{children:"Key Takeaways:"}),children:[(0,r.jsx)(s.ck,{children:"useCallback memoizes functions to prevent unnecessary re-creations."}),(0,r.jsx)(s.ck,{children:"It accepts two arguments: the function to memoize and a dependency array."}),(0,r.jsx)(s.ck,{children:"The function is only re-created if one of the dependencies changes."}),(0,r.jsx)(s.ck,{children:(0,r.jsxs)(s.EY,{children:["Using useCallback can optimize performance but should be used judiciously to"," ",(0,r.jsx)(m,{children:"avoid overly complex dependency arrays and unnecessary memoization overhead."})]})})]}),(0,r.jsx)(s.EY,{style:{marginTop:"0.5rem"},children:"In summary, useCallback is a powerful tool for optimizing performance in React applications by controlling when functions are re-created and preventing unnecessary re-renders."})]})})]}),!h&&(0,r.jsx)(s.Sr,{top:"6rem",right:"4rem",children:a.map((n=>(0,r.jsx)(s.WW,{size:"small",selected:e===n.id,onClick:()=>(e=>{const n=document.getElementById(e);n&&n.scrollIntoView({behavior:"smooth",block:"start",inline:"nearest"})})(n.id),children:n.title},n.id)))})]}):(0,r.jsx)(o.Hk,{children:null})}}}]);
//# sourceMappingURL=872.de2278e7.chunk.js.map