"use strict";(self.webpackChunkcstutor=self.webpackChunkcstutor||[]).push([[322],{7322:(e,n,t)=>{t.r(n),t.d(n,{default:()=>o});var r=t(5043),s=t(1290),i=t(4306),c=t(7987),a=t(579);const l=[{id:"introduction",title:"Introduction"},{id:"detailed-breakdown",title:"Detailed Breakdown"},{id:"summary",title:"Summary"}],o=()=>{const[e,n]=r.useState("introduction"),[t,o]=r.useState(!1),{width:u}=(0,c.lW)(),d=u<1200;r.useEffect((()=>{o(!0)}),[]),r.useEffect((()=>{const e=new IntersectionObserver((e=>{for(const t of e)if(t.isIntersecting){n(t.target.id);break}}),{threshold:1,rootMargin:"64px"});return l.map((e=>document.getElementById(e.id))).forEach((n=>{if(n)return e.observe(n)})),()=>{e.disconnect()}}));const h=(0,i.DP)().theme.colorPalette.primary.accentScale[10],m=e=>{let{children:n}=e;return(0,a.jsx)("span",{style:{color:h},children:n})},f=(0,a.jsxs)(i.EY,{children:["useRef is a hook in React that provides a way to create a mutable object which persists for the lifetime of the component. It is often used for",(0,a.jsxs)(m,{children:[" ","accessing and manipulating DOM elements directly, storing mutable values that do not cause re-renders when updated,"]})," ","and maintaining values across renders without triggering a component update."]});return t?(0,a.jsxs)(s.Hk,{children:[(0,a.jsxs)(s._f,{style:{width:d?"100%":"calc(100% - 12rem"},className:t?"fade-in":"",children:[(0,a.jsx)(s.PZ,{children:(0,a.jsxs)(s.db,{id:"introduction",children:[(0,a.jsxs)(i.BI,{size:"small",color:"primary",delimiter:"/",children:[(0,a.jsx)(i.yd,{title:"Hooks"}),(0,a.jsx)(i.yd,{link:"/hooks/use-ref",title:"useRef"})]}),(0,a.jsx)(i.EY,{size:"large",children:"Introduction"}),f]})}),(0,a.jsxs)(s.PZ,{id:"detailed-breakdown",children:[(0,a.jsxs)(s.db,{children:[(0,a.jsx)(i.EY,{size:"large",children:"Detailed Breakdown of useRef"}),(0,a.jsx)(i.EY,{children:"Importing useRef "}),(0,a.jsx)(i.EY,{children:"To use useRef, you need to import it from React:"}),(0,a.jsx)(i.sY,{language:"javascript",text:"import React, { useRef } from 'react';"})]}),(0,a.jsxs)(s.db,{children:[(0,a.jsx)(i.EY,{children:"Basic Usage"}),(0,a.jsxs)(i.EY,{children:["useRef returns a mutable object that persists for the lifetime of the component."," ",(0,a.jsx)(m,{children:"It accepts an optional initial value as an argument."})]}),(0,a.jsx)(i.sY,{language:"javascript",text:"const myRef = useRef(initialValue);"})]}),(0,a.jsx)(s.db,{children:(0,a.jsxs)(i.B8,{title:(0,a.jsx)(i.EY,{children:"Example Usage"}),children:[(0,a.jsxs)(i.ck,{children:[(0,a.jsx)(i.EY,{children:"Accessing DOM Elements:"}),(0,a.jsx)(i.EY,{style:{marginTop:"0.25rem"},children:"useRef is commonly used to access DOM elements directly."}),(0,a.jsx)(i.sY,{style:{marginTop:"0.5rem"},language:"javascript",text:"import React, { useRef, useEffect } from 'react';\n\nfunction MyComponent() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // Focus the input element when the component mounts\n    inputRef.current.focus();\n  }, []);\n\n  return <input ref={inputRef} type=\"text\" />;\n}\n"}),(0,a.jsxs)(i.B8,{variant:"unordered",children:[(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:["inputRef is created using useRef(null),"," ",(0,a.jsx)(m,{children:"initializing it with null."})]})}),(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:["The ref attribute of the input element is set to inputRef,"," ",(0,a.jsx)(m,{children:"connecting the DOM element to the ref."})]})}),(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:["In the useEffect hook,"," ",(0,a.jsx)(m,{children:"inputRef.current"})," gives direct access to the DOM element, allowing us to call the focus method on it."]})})]})]}),(0,a.jsxs)(i.ck,{style:{marginTop:"0.25rem"},children:[(0,a.jsx)(i.EY,{children:"Storing Mutable Values"}),(0,a.jsx)(i.EY,{style:{marginTop:"0.25rem"},children:"useRef can store values that persist across renders without causing re-renders."}),(0,a.jsx)(i.sY,{style:{marginTop:"0.5rem"},language:"javascript",text:"import React, { useRef, useState } from 'react';\n\nfunction Counter() {\n  const count = useRef(0);\n  const [, setRender] = useState(0);\n\n  const increment = () => {\n    count.current++;\n    console.log(count.current);\n  };\n\n  return (\n    <div>\n      <button onClick={increment}>Increment</button>\n      <button onClick={() => setRender(render => render + 1)}>Force Render</button>\n    </div>\n  );\n}\n"}),(0,a.jsxs)(i.B8,{variant:"unordered",children:[(0,a.jsx)(i.ck,{children:"count is created using useRef(0), initializing it with 0."}),(0,a.jsx)(i.ck,{children:"count.current is incremented in the increment function without causing a re-render."}),(0,a.jsx)(i.ck,{children:"The Force Render button uses setRender to force a re-render, demonstrating that count.current retains its value across renders."})]})]}),(0,a.jsxs)(i.ck,{style:{marginTop:"0.25rem"},children:[(0,a.jsx)(i.EY,{children:"Persisting Values Across Renders:"}),(0,a.jsx)(i.EY,{style:{marginTop:"0.25rem"},children:"useRef can be used to keep track of values that need to persist across renders but do not require re-rendering when updated."}),(0,a.jsx)(i.sY,{style:{marginTop:"0.5rem"},language:"javascript",text:"import React, { useRef, useEffect } from 'react';\n\nfunction Timer() {\n  const intervalId = useRef(null);\n  const count = useRef(0);\n\n  useEffect(() => {\n    intervalId.current = setInterval(() => {\n      count.current++;\n      console.log(count.current);\n    }, 1000);\n\n    return () => clearInterval(intervalId.current);\n  }, []);\n\n  return <div>Check the console for the count</div>;\n}\n"}),(0,a.jsxs)(i.B8,{variant:"unordered",children:[(0,a.jsx)(i.ck,{children:"intervalId is created using useRef(null), initializing it with null."}),(0,a.jsx)(i.ck,{children:"count is created using useRef(0), initializing it with 0."}),(0,a.jsx)(i.ck,{children:"In the useEffect hook, intervalId.current stores the ID of the interval, and count.current is incremented every second."}),(0,a.jsx)(i.ck,{children:"The cleanup function clears the interval using intervalId.current."})]})]})]})})]}),(0,a.jsxs)(s.PZ,{id:"summary",children:[(0,a.jsx)(s.db,{children:(0,a.jsxs)(i.B8,{title:(0,a.jsx)(i.EY,{size:"large",children:"Summary"}),children:[(0,a.jsx)(i.ck,{children:"Initialization: useRef(initialValue) returns a ref object with a current property set to initialValue."}),(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:["DOM Access: Attach the ref to a DOM element using the ref attribute."," ",(0,a.jsx)(m,{children:"Access the element via ref.current"})]})}),(0,a.jsx)(i.ck,{children:"Mutable Values: Store mutable values that persist across renders without causing re-renders."}),(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:["Persistent Values: Maintain values across renders without causing re-renders,"," ",(0,a.jsx)(m,{children:"suitable for storing interval IDs, timers, and other values."})]})})]})}),(0,a.jsx)(s.db,{children:(0,a.jsx)(i.EY,{children:"useRef is a versatile hook that helps manage mutable values and direct DOM manipulations in functional components, making it a crucial tool for complex React applications."})})]})]}),!d&&(0,a.jsx)(i.Sr,{top:"6rem",right:"4rem",children:l.map((n=>(0,a.jsx)(i.WW,{size:"small",selected:e===n.id,onClick:()=>(e=>{const n=document.getElementById(e);n&&n.scrollIntoView({behavior:"smooth",block:"start",inline:"nearest"})})(n.id),children:n.title},n.id)))})]}):(0,a.jsx)(s.Hk,{children:null})}}}]);
//# sourceMappingURL=322.2218a494.chunk.js.map