/*! For license information please see 166.af788cb2.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkcstutor=self.webpackChunkcstutor||[]).push([[166],{166:(e,n,t)=>{t.r(n),t.d(n,{default:()=>d});var s=t(5043),c=t(1290),i=t(4306),o=t(7627),r=t(7987),a=t(579);const l=[{id:"introduction",title:"Introduction"},{id:"basic-usage",title:"Basic Usage"},{id:"examples",title:"Examples"},{id:"rules-of-hooks",title:"Rules of Hooks"},{id:"common-side-effect",title:"Common Side Effects"},{id:"tips-and-best-practices",title:"Tips and Best Practices"}],d=()=>{const[e,n]=s.useState("introduction"),[t,d]=s.useState(!1),{width:h}=(0,r.lW)(),u=h<1200;s.useEffect((()=>{d(!0)}),[]);const f=(0,i.DP)().theme.colorPalette.primary.accentScale[10],m=(0,i.DP)().theme.colorPalette.info.accentScale[10],p=e=>{let{children:n}=e;return(0,a.jsx)("span",{style:{color:f},children:n})},x=(0,a.jsxs)(i.EY,{children:["useEffect is a Hook in React that allows you to"," ",(0,a.jsx)(p,{children:"perform side effects in function components"}),". It serves a similar purpose to lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount in class components."]}),j=(0,a.jsxs)(i.EY,{children:[(0,a.jsx)(p,{children:"Function:"})," This is the effect function where you write the side effect code. This function can optionally return a cleanup function, which is used to clean up the effect (like removing event listeners or canceling network requests) before the component is unmounted or before the effect runs again.`;"]}),y=(0,a.jsxs)(i.EY,{children:[(0,a.jsx)(p,{children:"Dependency Array:"})," This is an array of values that the effect depends on. The effect will only run when one or more of these values change. If you omit this array, the effect will run after every render. If you pass an empty array, the effect will run only once, similar to componentDidMount."]}),g=(0,a.jsxs)(i.EY,{noColor:!0,children:["useEffect is inspired by React's class component lifecycle methods, specifically componentDidMount, componentDidUpdate, and componentWillUnmount. ",(0,a.jsx)("br",{}),(0,a.jsx)("br",{}),"However, unlike class components, useEffect merges these three lifecycle phases into a single, versatile hook that can handle side effects before and after renders.",(0,a.jsx)("br",{}),"This means with useEffect, you can manage side effects in one place, making functional components more powerful and concise than class components, which required separate methods for these tasks. This is why useEffect is often referred to as the"," ",(0,a.jsx)("span",{style:{color:m},children:"Swiss Army knife"})," of React hooks!"]});s.useEffect((()=>{const e=new IntersectionObserver((e=>{for(const t of e)if(t.isIntersecting){n(t.target.id);break}}),{threshold:1,rootMargin:"64px"});return l.map((e=>document.getElementById(e.id))).forEach((n=>{if(n)return e.observe(n)})),()=>{e.disconnect()}}));return t?(0,a.jsxs)(c.Hk,{children:[(0,a.jsxs)(c._f,{style:{width:u?"100%":"calc(100% - 12rem"},className:t?"fade-in":"",children:[(0,a.jsx)(c.PZ,{children:(0,a.jsxs)(c.db,{id:"introduction",children:[(0,a.jsxs)(i.BI,{size:"small",color:"primary",delimiter:"/",children:[(0,a.jsx)(i.yd,{title:"Hooks"}),(0,a.jsx)(i.yd,{link:"/hooks/use-effect",title:"useEffect"})]}),(0,a.jsx)(i.Fc,{color:"info",titleIcon:(0,a.jsx)(o.A,{}),title:"Fun Fact",description:g,style:{marginTop:"0.5rem"}}),(0,a.jsx)(i.EY,{size:"large",style:{marginTop:"0.5rem"},children:"Introduction"}),x]})}),(0,a.jsx)(c.PZ,{children:(0,a.jsxs)(c.db,{id:"basic-usage",children:[(0,a.jsx)(i.EY,{size:"large",children:"Basic Usage"}),(0,a.jsxs)(i.EY,{children:["The useEffect hook takes two arguments:"," ",(0,a.jsx)(p,{children:"a function and a dependency array"}),"."]}),(0,a.jsx)(i.sY,{language:"JSX",text:"useEffect(() => {\n  // Side effect code here\n  return () => {\n    // Cleanup code here\n  };\n}, [dependencies]);\n"}),(0,a.jsxs)(i.B8,{variant:"unordered",children:[(0,a.jsx)(i.ck,{children:j}),(0,a.jsx)(i.ck,{children:y})]})]})}),(0,a.jsx)(c.PZ,{children:(0,a.jsx)(c.db,{id:"examples",children:(0,a.jsxs)(i.B8,{variant:"ordered",title:(0,a.jsx)(i.EY,{size:"large",children:"Examples:"}),children:[(0,a.jsxs)(i.ck,{children:[(0,a.jsx)(i.EY,{children:"Basic Example:"}),(0,a.jsx)(i.sY,{style:{marginTop:"0.5rem"},language:"JSX",text:"import React, { useEffect, useState } from 'react';\n\nfunction ExampleComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  }, [count]); // Only re-run the effect if count changes\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n"}),(0,a.jsx)(i.EY,{style:{marginTop:"1rem"},children:"In this example, the effect updates the document title whenever the count state changes."})]}),(0,a.jsxs)(i.ck,{style:{marginTop:"0.5rem"},children:[(0,a.jsx)(i.EY,{children:"Effect with Cleanup:"}),(0,a.jsx)(i.sY,{style:{marginTop:"0.5rem"},language:"JSX",text:"import React, { useEffect, useState } from 'react';\n\nfunction Timer() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setCount(c => c + 1);\n    }, 1000);\n\n    return () => clearInterval(interval); // Cleanup interval on unmount\n  }, []); // Empty array ensures the effect runs only once\n\n  return <div>{count}</div>;\n}\n"}),(0,a.jsx)(i.EY,{style:{marginTop:"1rem"},children:"Here, we start an interval that updates the count every second. The cleanup function (clearInterval) ensures the interval is cleared when the component unmounts, preventing memory leaks."})]}),(0,a.jsxs)(i.ck,{style:{marginTop:"0.5rem"},children:[(0,a.jsx)(i.EY,{children:"Conditional Effect:"}),(0,a.jsx)(i.sY,{style:{marginTop:"0.5rem"},language:"JSX",text:"import React, { useEffect, useState } from 'react';\n\nfunction FetchData() {\n  const [data, setData] = useState(null);\n  const [id, setId] = useState(1);\n\n  useEffect(() => {\n    fetch(`https://jsonplaceholder.typicode.com/posts/${id}`)\n      .then(response => response.json())\n      .then(data => setData(data));\n  }, [id]); // Fetch data only when `id` changes\n\n  return (\n    <div>\n      <button onClick={() => setId(id + 1)}>Next Post</button>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n    </div>\n  );\n}\n"}),(0,a.jsx)(i.EY,{style:{marginTop:"1rem"},children:"This effect fetches data from an API whenever the id state changes. The dependency array [id] ensures the effect runs only when id changes."})]})]})})}),(0,a.jsx)(c.PZ,{children:(0,a.jsx)(c.db,{id:"rules-of-hooks",children:(0,a.jsxs)(i.B8,{variant:"unordered",title:(0,a.jsx)(i.EY,{size:"large",children:"Rules of Hooks"}),children:[(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:[(0,a.jsx)(p,{children:"Call Hooks at the Top Level:"})," Don't call hooks inside loops, conditions, or nested functions. Always use hooks at the top level of your React function so that the hooks are called in the same order each time a component renders."]})}),(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:[(0,a.jsx)(p,{children:"Call Hooks from React Functions:"})," ","Only call hooks from React function components or custom hooks."]})})]})})}),(0,a.jsx)(c.PZ,{children:(0,a.jsx)(c.db,{id:"common-side-effect",children:(0,a.jsxs)(i.B8,{variant:"unordered",title:(0,a.jsx)(i.EY,{size:"large",children:"Common Side Effects"}),children:[(0,a.jsxs)(i.ck,{children:[(0,a.jsx)(i.EY,{children:"Data fetching"}),(0,a.jsxs)(i.EY,{children:["Typically, you want to"," ",(0,a.jsx)(p,{children:"fetch data from an API"})," and update the state with the fetched data."]})]}),(0,a.jsxs)(i.ck,{children:[(0,a.jsx)(i.EY,{children:"Setting up subscriptions"}),(0,a.jsxs)(i.EY,{children:["You can create a connection or subscription"," ",(0,a.jsx)(p,{children:"(like a WebSocket, event listener, or data stream)"})," ","when a component mounts and cleaning it up when the component unmounts or dependencies change"]}),(0,a.jsxs)(i.B8,{title:"Steps:",containerStyle:{marginTop:"0.5rem"},children:[(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:[(0,a.jsx)(p,{children:"Initialize the Subscription:"})," ","Inside the useEffect, set up the subscription, such as opening a WebSocket connection or adding an event listener."]})}),(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:[(0,a.jsx)(p,{children:"Handle Data/Updates:"})," Define a function within the useEffect to handle incoming data or events, updating the component's state accordingly."]})}),(0,a.jsxs)(i.ck,{children:[(0,a.jsxs)(i.EY,{children:[(0,a.jsx)(p,{children:"Clean Up:"})," Return a cleanup function from useEffect to close the connection or remove the event listener when the component unmounts or when dependencies change."]}),(0,a.jsx)(i.sY,{style:{marginTop:"0.5rem"},text:"useEffect(() => {\n  const socket = new WebSocket('wss://example.com/socket');\n\n  socket.addEventListener('message', (event) => {\n    setMessage(event.data); // Handle incoming data\n  });\n\n  return () => {\n    socket.close(); // Clean up the subscription\n  };\n}, []); // Empty array means this effect runs only on mount and unmount\n",language:"javascript"})]})]})]}),(0,a.jsx)(i.ck,{style:{marginTop:"0.25rem"},children:(0,a.jsx)(i.EY,{children:"Manually changing the DOM"})}),(0,a.jsx)(i.ck,{children:"Timers (e.g., setTimeout and setInterval)"}),(0,a.jsx)(i.ck,{children:"Logging"})]})})}),(0,a.jsxs)(c.PZ,{children:[(0,a.jsx)(c.db,{id:"tips-and-best-practices",children:(0,a.jsxs)(i.B8,{title:(0,a.jsx)(i.EY,{size:"large",children:"Tips And Best Practices"}),children:[(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:["Use the ",(0,a.jsx)(p,{children:"dependency array"})," to control when the effect runs."]})}),(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:["Use ",(0,a.jsx)(p,{children:"cleanup functions"})," to prevent memory leaks and clean up resources."]})}),(0,a.jsx)(i.ck,{children:"Be mindful of the dependencies you include in the dependency array."}),(0,a.jsx)(i.ck,{children:(0,a.jsxs)(i.EY,{children:["Avoid using the dependency array as an"," ",(0,a.jsx)(p,{children:"optimization technique."})]})})]})}),(0,a.jsx)(c.db,{children:(0,a.jsx)(i.EY,{children:"By understanding and using useEffect properly, you can manage side effects in your React components effectively and ensure they behave as expected throughout their lifecycle."})})]})]}),!u&&(0,a.jsx)(i.Sr,{top:"6rem",right:"4rem",children:l.map((n=>(0,a.jsx)(i.WW,{size:"small",selected:e===n.id,onClick:()=>(e=>{const n=document.getElementById(e);n&&n.scrollIntoView({behavior:"smooth",block:"start",inline:"nearest"})})(n.id),children:n.title},n.id)))})]}):(0,a.jsx)(c.Hk,{children:null})}},7627:(e,n,t)=>{t.d(n,{A:()=>s});var s=(0,t(4648).A)("outline","mood-smile-dizzy","IconMoodSmileDizzy",[["path",{d:"M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0",key:"svg-0"}],["path",{d:"M14.5 15a3.5 3.5 0 0 1 -5 0",key:"svg-1"}],["path",{d:"M8 9l2 2",key:"svg-2"}],["path",{d:"M10 9l-2 2",key:"svg-3"}],["path",{d:"M14 9l2 2",key:"svg-4"}],["path",{d:"M16 9l-2 2",key:"svg-5"}]])}}]);
//# sourceMappingURL=166.af788cb2.chunk.js.map